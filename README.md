# AWSProject

This project looked to deploy a flask app on AWS using services learnt over the last two weeks. The MVP consisted of a custom VPC, with a public subnet and two private subnets. The public subnet was to contain an EC2 running the web app, and the private subnet was to have a RDS database in it to store tables for the web app. The EC2 and RDS database were also to have their own security groups.

To do this I initially set up a neww VPC and then created the subnets. To create the public subnet, I had to use an Internet gateway (connecting it to the VPC), then modifying the route table for that subnet to allow all inbound traffic from the internet gateway. For the private subnet, the route table was set to only allow inbound traffic from sources within the VPC. When creating the EC2 Instance, a security group was assigned to it on creation, which accepted any inbound traffic from a HTTP connection on port 80, and also an SSH connection from my IP address only. The RDS was created with a security group which accepted any connection from an EC2 in the EC2 Security Group. Also with the creation of the RDS, it was assigned to both private subnets created, which are in different Availibility Zones (AZs). This is particularly good for the availability of the product as the RDS can still run should one AZ go down. 
![image](https://user-images.githubusercontent.com/88770784/135596768-f6e6d41f-f082-481e-8992-b87430b4a1b1.png)

To improve upon the MVP of this project, there were a few things to be considered. Firstly, since the RDS is available in multiple AZs, it would make sense to also have EC2s running in each AZ as well, to improve the availaibilty of the front end (should an AZ go down). Also, if the traffic to the web app were to suddenly spike or become much greater, implementing an Auto-scaling Group and assigning it a Load Balancer would make sense. Additional layers of security are also important additions, especially considering that credentials such as the RDS URI are visible in the apps code. Finally, automating the whole deployment of the app onto AWS would be particularly beneficial for easing the amount of work needed in the future, only having to monitor the deployment rather than carry it out manually.

Firstly, to deal with the possibility of increased traffic and auto-scaling group and load balancer were created. In the creation of the instances however, the packages required to run the web app were not automatically installed as a custom Amazon MAchine Image(AMI) was not created from the original EC2 before creating the ASG.

